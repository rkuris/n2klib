// Generate classes from PGNs
// We currently only generate a few of them
#include <sys/stat.h>

#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <regex>
#include <cctype>

#include "framework/json.hpp"
#include "framework/inja.hpp"

using json = nlohmann::json;
using namespace std;
using namespace inja;

// This is the template that is filled in from the JSON input file.
// The JSON file describes each field in detail.
const char *tstr = R"TEMPLATE(// class {{ Id }}

// Automatically generated by mkmsgs - DO NOT EDIT
// Description: {{ Description }}
#include "../n2k.h"
namespace n2k {
  class {{ Id }} : public Message {
  public:
## if isArray(Fields)
##  for field in Fields
##    if existsIn(field, "EnumValues")
    enum class {{ idname(field) }}:unsigned char {
##     for v in field.EnumValues
      {{ enumname(v.name) }} = {{ v.value }}{% if not loop.is_last %},{% endif %}
##     endfor
    };

##    endif
##  endfor
## endif
    {{ Id }}() {};
    {{ Id }}(const Message &m) : Message(m) {};
## if isArray(Fields)
##  for field in Fields
##   if field.Id != "reserved"
    {{ getter(field) }};
##   endif
##  endfor
## else
    {{ getter(Fields.Field) }};
## endif
    static const pgn_t PGN = {{ PGN }};
    static const PGNType Type = PGNType::{{ Type }};
    pgn_t getPGN() const { return PGN; }
  };
}
)TEMPLATE";

class FieldData {
	public:
	int offset;
	int length;
	string id;
	double factor;

	FieldData(const json *field) {
	    length = field->at("BitLength").get<int>();
	    offset = -1;
	    if (field->contains("BitOffset")) {
		offset = field->at("BitOffset").get<int>();
	    }
	    id = field->at("Id").get<string>();
	}
};

int main(int argc, char *argv[]) {
    // Parse the pgns.json file
	const std::string filename = "pgns.json";
    json j;
    ifstream pgnfile(filename);
	if (pgnfile.fail()) {
		cerr << "Cannot open '" << filename << "': " << strerror(errno) << "\n";
		cerr << "Run make pgns.json to (re)create pgns.json\n";
		exit(1);
	}
    pgnfile >> j;
    std::map<string, int> seenFields;

    mkdir("generated", 0777);
    int needed[] = { 
		     // required for transmission
		     59392, /* iso ack */
	    	     59904, /* iso req */
		     60160, /* multi packet data transfer TP.DT */
		     60416, /* multi packet conn mgmt TP.CM */
		     60928, /* iso address claim */
		     126208, /* group function */
		     126464, /* PGN list */
		     126993, /* Heartbeat */
		     126996, /* product information */
		     126998, /* config information */

		     // user (these should be in argv)

        	     127250, /* heading */
		     128259, /* speed through water */
        	     128267, /* depth */
		     129038, /* AIS type A position report */
		     129039, /* AIS type B position report */
		     130306, /* environmental parameters */
		     130310, /* environmental parameters */
		     130311, /* environmental parameters */
		     130312, /* temperature */
		     130316 /* temperatureExtendedRange */
    };


    json pgns = j["PGNs"];
    Environment env;
    env.add_callback("idname", 1, [](Arguments& args) {
       auto field = args.at(0);
       string id = field->at("Id").get<string>();
       id[0] = toupper(id[0]);
       return id;
    });
    env.add_callback("getter", 1, [&seenFields](Arguments& args) {
	    FieldData f(args.at(0));

	    auto field = args.at(0);
	    auto seen = seenFields.find(f.id);
	    auto sofar = 1;
	    if (seen != seenFields.end()) {
	       f.id += "_" + to_string(seen->second);
	       sofar = seen->second + 1;
            }
            seenFields[f.id] = sofar;
	    f.id[0] = toupper(f.id[0]);
	    string getterArgs = to_string(f.offset) + "," + to_string(f.length);
	    string getter = "Get(" + getterArgs + ")";
	    if (field->contains("Resolution") && (!field->contains("Type")||field->at("Type")!="Integer")) {
	        auto factor = 1.0;
	        auto res = field->at("Resolution");
		auto suffix = "";
		string raw = "";
		if (field->contains("Units")) {
		   auto units = field->at("Units").get<string>();
		   if (units == "rad") {
		       factor = 180/M_PI;
		       suffix = "Degrees";
		       raw = "Radians";
		   } else if (units == "m/s") {
		       factor = 1.94384;
		       suffix = "Knots";
		       raw = "MetersPerSecond";
		   } else if (units == "m") {
		       factor = 3.28084;
		       suffix = "Feet";
		       raw = "Meters";
		   }
	        }
		auto resDouble = res.get<double>();
		char dbl[32];
		string setter;
		if (raw != "") {
			std::snprintf(dbl, sizeof(dbl), "%G", resDouble);
			// set with SI units
			setter = "void set" + f.id + raw + "(double value) { Set(value/" + dbl + "," + getterArgs + "); }\n    ";
			// get with SI units
			setter += "double get" + f.id + raw + "() const { return " + dbl + " * " + getter + "; }\n    ";
		}
		std::snprintf(dbl, sizeof(dbl), "%G", factor * resDouble);
		// set with imperial units
		setter += "void set" + f.id + suffix + "(double value) { Set(value/" + dbl + "," + getterArgs + "); }\n    ";
		// get with imperial units
		setter += "double get" + f.id + suffix + "() const { return " + dbl + " * " + getter + "; }";
		return setter;
	    }
	    string type;
	    string cast = "";
	    string reverseCast = "";
	    if (field->contains("EnumValues")) {
		type = f.id;
		cast = "(" + type + ")";
		reverseCast = "(unsigned char)";
	    } else if (f.length <= 8)
		type = "unsigned char";
	    else if (f.length <=16)
		type ="unsigned short";
	    else if (f.length <= 32)
		    type = "unsigned long";
	    else
		type = "";
	    string setter = "void set" + f.id + "(" + type + " value) { Set(" + reverseCast + "value," + getterArgs + "); }\n    ";
	    return string(setter + type + " get" + f.id + "() const { return " + cast + getter + "; }");
    });
    env.add_callback("enumname", 1, [](Arguments& args) {
	    regex e ("[^A-Za-z0-9]+");
	    string orig = args.at(0)->get<string>();
	    return regex_replace(orig, e, "_");
	    });
    Template temp = env.parse(tstr);
    for (json::iterator it = pgns.begin(); it != pgns.end(); ++it) {
	    auto pgnid = (*it)["PGN"].get<int>();
	    cout << "Processing PGN " << pgnid << "\n";
	    if (binary_search(needed, needed + sizeof(needed) / sizeof(int), pgnid)) {
		    seenFields.clear();
		    string classname = (*it)["Id"].get<string>();
		    string filename = "generated/" + classname + ".cc";
		    ofstream classfile(filename);
		    classname[0] = toupper(classname[0]);
		    (*it)["Id"] = classname;
		    env.render_to(classfile, temp, *it);
		    classfile.close();
	    }
    }
}
